package gnolang

import (
	"fmt"
	"math"
	"reflect"
	"unsafe"

	"github.com/gnolang/gno/gnovm/pkg/gnolang/internal/softfloat"
)

// GoNative, *NativeType, and *NativeValue are experimental and subject to
// change. These functions were originally created for bootstrapping Gno's
// (file) tests from the Yaegi project (which imported complex standard
// libraries). Then later they became used for native bindings in autogenerated
// code (see stdlibs/generated.go).
//
// Due to the limitations of Go reflection and due to the complexity of
// converting complex recursive data structures, neither Go2Gno* nor Gno2Go*
// will ever be complete for the general case.
//
// NOTE This means that new native bindings must conform to these limitations,
// namely use these for message-passing objects (read-only copies), rather than
// relying on much intelligence, such as those offered by go2GnoValueUpdate().
//
// TODO list and document the limitations.
//
//  * Go 1.15 reflect has a bug in creating new types with methods -- namely,
//  it cannot, and so you cannot create types through reflection that obey any
//  interface but the empty interface.
//  * ...

// ----------------------------------------
// Go to Gno conversion

// See go2GnoValue(); this is lazy.
func go2GnoType(rt reflect.Type) Type {
	return go2GnoBaseType(rt)
}

// like go2GnoType() but ignores name declaration.
// for native type unary/binary expression conversion.
// also used for untyped gno -> native conversion intermediary.
// XXX support unary conversions as we did for binary.
func go2GnoBaseType(rt reflect.Type) Type {
	switch rk := rt.Kind(); rk {
	case reflect.Bool:
		return BoolType
	case reflect.String:
		return StringType
	case reflect.Int:
		return IntType
	case reflect.Int8:
		return Int8Type
	case reflect.Int16:
		return Int16Type
	case reflect.Int32:
		return Int32Type
	case reflect.Int64:
		return Int64Type
	case reflect.Uint:
		return UintType
	case reflect.Uint8:
		return Uint8Type
	case reflect.Uint16:
		return Uint16Type
	case reflect.Uint32:
		return Uint32Type
	case reflect.Uint64:
		return Uint64Type
	case reflect.Float32:
		return Float32Type
	case reflect.Float64:
		return Float64Type
	case reflect.Array:
		return &ArrayType{
			Elt: go2GnoType(rt.Elem()),
			Len: rt.Len(),
			Vrd: false,
		}
	case reflect.Slice:
		return &SliceType{
			Elt: go2GnoType(rt.Elem()),
			Vrd: false,
		}
	case reflect.Ptr:
		return &PointerType{
			Elt: go2GnoType(rt.Elem()), // recursive
		}
	case reflect.UnsafePointer:
		panic("not yet implemented")
	default:
		panic(fmt.Sprintf(
			"unexpected type %v", rt))
	}
}

// Implements Store.
// See go2GnoValue2(). Like go2GnoType() but also converts any
// top-level complex types (or pointers to them).  The result gets
// memoized in *NativeType.GnoType() for type inference in the
// preprocessor, as well as in the cacheNativeTypes lookup map to
// support recursive translations.
// The namedness of the native type gets converted to an
// appropriate gno *DeclaredType with native methods
// converted via go2GnoFuncType().
func (ds *defaultStore) Go2GnoType(rt reflect.Type) (t Type) {
	if gnot, ok := ds.cacheNativeTypes[rt]; ok {
		return gnot
	}
	defer func() {
		if r := recover(); r != nil {
			panic(r) // do not run the below logic upon panic.
		}
		// regardless of rt kind, if rt.PkgPath() is set,
		// wrap t with declared type.
		pkgPath := rt.PkgPath()
		if pkgPath != "" {
			// mappings have been removed, so this should never happen.
			gokey := pkgPath + "." + rt.Name()
			panic(fmt.Sprintf("native type does not exist for %s", gokey))
		}
		// memoize t to cache.
		if debug {
			if gnot, ok := ds.cacheNativeTypes[rt]; ok {
				if gnot.TypeID() != baseOf(t).TypeID() {
					panic("should not happen")
				}
			}
		}
		ds.cacheNativeTypes[rt] = t // may overwrite
	}()
	switch rk := rt.Kind(); rk {
	case reflect.Bool:
		return BoolType
	case reflect.String:
		return StringType
	case reflect.Int:
		return IntType
	case reflect.Int8:
		return Int8Type
	case reflect.Int16:
		return Int16Type
	case reflect.Int32:
		return Int32Type
	case reflect.Int64:
		return Int64Type
	case reflect.Uint:
		return UintType
	case reflect.Uint8:
		return Uint8Type
	case reflect.Uint16:
		return Uint16Type
	case reflect.Uint32:
		return Uint32Type
	case reflect.Uint64:
		return Uint64Type
	case reflect.Float32:
		return Float32Type
	case reflect.Float64:
		return Float64Type
	case reflect.Array:
		// predefine gno type
		at := &ArrayType{}
		ds.cacheNativeTypes[rt] = at
		// define gno type
		at.Len = rt.Len()
		at.Elt = go2GnoType(rt.Elem())
		at.Vrd = false
		return at
	case reflect.Slice:
		return &SliceType{
			Elt: go2GnoType(rt.Elem()),
			Vrd: false,
		}
	case reflect.Chan:
		// predefine gno type
		ct := &ChanType{}
		ds.cacheNativeTypes[rt] = ct
		// define gno type
		chdir := toChanDir(rt.ChanDir())
		ct.Dir = chdir
		ct.Elt = go2GnoType(rt.Elem())
		return ct
	case reflect.Func:
		return ds.go2GnoFuncType(rt)
	case reflect.Interface:
		// predefine gno type
		it := &InterfaceType{}
		ds.cacheNativeTypes[rt] = it
		// define gno type
		nm := rt.NumMethod()
		fs := make([]FieldType, nm)
		for i := 0; i < nm; i++ {
			mthd := rt.Method(i)
			fs[i] = FieldType{
				Name: Name(mthd.Name),
				Type: ds.Go2GnoType(mthd.Type), // recursive
			}
		}
		it.PkgPath = rt.PkgPath()
		it.Methods = fs
		return it
	case reflect.Map:
		// predefine gno type
		mt := &MapType{}
		ds.cacheNativeTypes[rt] = mt
		// define gno type
		mt.Key = go2GnoType(rt.Key())
		mt.Value = go2GnoType(rt.Elem())
		return mt
	case reflect.Ptr:
		return &PointerType{
			Elt: ds.Go2GnoType(rt.Elem()), // recursive
		}
	case reflect.Struct:
		// predefine gno type
		st := &StructType{}
		ds.cacheNativeTypes[rt] = st
		// define gno type
		nf := rt.NumField()
		fs := make([]FieldType, nf)
		for i := 0; i < nf; i++ {
			sf := rt.Field(i)
			fs[i] = FieldType{
				Name: Name(sf.Name),
				Type: go2GnoType(sf.Type),
			}
		}
		st.PkgPath = rt.PkgPath()
		st.Fields = fs
		return st
	case reflect.UnsafePointer:
		panic("not yet implemented")
	default:
		panic("not yet implemented")
	}
}

// Converts native go function type to gno *FuncType,
// for the preprocessor to infer types of arguments.
// The argument and return types are shallowly converted
// to gno types, (to preserve the original native types).
func (ds *defaultStore) go2GnoFuncType(rt reflect.Type) *FuncType {
	// predefine func type
	ft := &FuncType{}
	ds.cacheNativeTypes[rt] = ft
	// define func type
	hasVargs := rt.IsVariadic()
	ins := make([]FieldType, rt.NumIn())
	for i := 0; i < len(ins); i++ {
		it := go2GnoType(rt.In(i))
		if hasVargs && i == len(ins)-1 {
			it = &SliceType{
				Elt: it.Elem(),
				Vrd: true,
			}
		}
		ins[i] = FieldType{
			Name: "", // XXX dontcare?
			Type: it,
		}
	}
	outs := make([]FieldType, rt.NumOut())
	for i := 0; i < len(outs); i++ {
		ot := go2GnoType(rt.Out(i))
		outs[i] = FieldType{
			Name: "", // XXX dontcare?
			Type: ot,
		}
	}
	ft.Params = ins
	ft.Results = outs
	return ft
}

// NOTE: used by vm module.  Recursively converts.
func Go2GnoValue(alloc *Allocator, store Store, rv reflect.Value) (tv TypedValue) {
	return go2GnoValue2(alloc, store, rv, true)
}

// NOTE: used by imports_test.go TestSetOriginCaller.
// See also gno2GoValue().
func Gno2GoValue(tv *TypedValue, rv reflect.Value) (ret reflect.Value) {
	return gno2GoValue(tv, rv)
}

// Default run-time representation of go-native values.  It is
// "lazy" in the sense that unnamed complex types like arrays and
// slices aren't translated to Gno canonical types except as
// *NativeType/*NativeValues, primarily for speed.  To force
// translation to Gno canonical types for unnamed complex types,
// call go2GnoValue2(), which is used by the implementation of
// ConvertTo().
// Unlike go2GnoValue2(), rv may be invalid.
func go2GnoValue(alloc *Allocator, rv reflect.Value) (tv TypedValue) {
	if !rv.IsValid() {
		return
	}
	if rv.Kind() == reflect.Interface {
		if rv.IsNil() {
			return TypedValue{}
		} else {
			rv = rv.Elem()
		}
	}
	if rv.Type().PkgPath() != "" {
		panic("should not happen")
	}
	tv.T = alloc.NewType(go2GnoType(rv.Type()))
	switch rk := rv.Kind(); rk {
	case reflect.Bool:
		tv.SetBool(rv.Bool())
	case reflect.String:
		tv.V = alloc.NewString(rv.String())
	case reflect.Int:
		tv.SetInt(rv.Int())
	case reflect.Int8:
		tv.SetInt8(int8(rv.Int()))
	case reflect.Int16:
		tv.SetInt16(int16(rv.Int()))
	case reflect.Int32:
		tv.SetInt32(int32(rv.Int()))
	case reflect.Int64:
		tv.SetInt64(rv.Int())
	case reflect.Uint:
		tv.SetUint(rv.Uint())
	case reflect.Uint8:
		tv.SetUint8(uint8(rv.Uint()))
	case reflect.Uint16:
		tv.SetUint16(uint16(rv.Uint()))
	case reflect.Uint32:
		tv.SetUint32(uint32(rv.Uint()))
	case reflect.Uint64:
		tv.SetUint64(rv.Uint())
	case reflect.Float32:
		tv.SetFloat32(softfloat.F64to32(math.Float64bits(rv.Float())))
	case reflect.Float64:
		tv.SetFloat64(math.Float64bits(rv.Float()))
	case reflect.Array:
		panic("not yet implemented")
	case reflect.Slice:
		panic("not yet implemented")
	case reflect.Chan:
		panic("not yet implemented")
	case reflect.Func:
		panic("not yet implemented")
	case reflect.Interface:
		panic("should not happen")
	case reflect.Map:
		panic("not yet implemented")
	case reflect.Ptr:
		panic("not yet implemented")
	case reflect.Struct:
		panic("not yet implemented")
	case reflect.UnsafePointer:
		panic("not yet implemented")
	default:
		panic("not yet implemented")
	}
	return
}

// If recursive is false, this function is like go2GnoValue() but less lazy
// (but still not recursive/eager). When recursive is false, it is for
// converting Go types to Gno types upon an explicit conversion (via
// ConvertTo).  Panics on unexported/private fields. Some types that cannot be
// converted remain native. Unlike go2GnoValue(), rv must be valid.
func go2GnoValue2(alloc *Allocator, store Store, rv reflect.Value, recursive bool) (tv TypedValue) {
	if debug {
		if !rv.IsValid() {
			panic("go2GnoValue2() requires valid rv")
		}
	}
	tv.T = store.Go2GnoType(rv.Type())
	switch rk := rv.Kind(); rk {
	case reflect.Bool:
		tv.SetBool(rv.Bool())
	case reflect.String:
		tv.V = alloc.NewString(rv.String())
	case reflect.Int:
		tv.SetInt(rv.Int())
	case reflect.Int8:
		tv.SetInt8(int8(rv.Int()))
	case reflect.Int16:
		tv.SetInt16(int16(rv.Int()))
	case reflect.Int32:
		tv.SetInt32(int32(rv.Int()))
	case reflect.Int64:
		tv.SetInt64(rv.Int())
	case reflect.Uint:
		tv.SetUint(rv.Uint())
	case reflect.Uint8:
		tv.SetUint8(uint8(rv.Uint()))
	case reflect.Uint16:
		tv.SetUint16(uint16(rv.Uint()))
	case reflect.Uint32:
		tv.SetUint32(uint32(rv.Uint()))
	case reflect.Uint64:
		tv.SetUint64(rv.Uint())
	case reflect.Float32:
		tv.SetFloat32(softfloat.F64to32(math.Float64bits(rv.Float())))
	case reflect.Float64:
		tv.SetFloat64(math.Float64bits(rv.Float()))
	case reflect.Array:
		rvl := rv.Len()
		if rv.Type().Elem().Kind() == reflect.Uint8 {
			av := alloc.NewDataArray(rvl)
			data := av.Data
			reflect.Copy(reflect.ValueOf(data), rv)
			tv.V = av
		} else {
			av := alloc.NewListArray(rvl)
			list := av.List
			for i := 0; i < rvl; i++ {
				if recursive {
					list[i] = go2GnoValue2(alloc, store, rv.Index(i), true)
				} else {
					list[i] = go2GnoValue(alloc, rv.Index(i))
				}
			}
			tv.V = av
		}
	case reflect.Slice:
		rvl := rv.Len()
		rvc := rv.Cap()
		list := make([]TypedValue, rvl, rvc)
		for i := 0; i < rvl; i++ {
			if recursive {
				list[i] = go2GnoValue2(alloc, store, rv.Index(i), true)
			} else {
				list[i] = go2GnoValue(alloc, rv.Index(i))
			}
		}
		tv.V = alloc.NewSliceFromList(list)
	case reflect.Chan:
		panic("not yet implemented")
	case reflect.Func:
		panic("not yet implemented")
	case reflect.Interface:
		panic("not yet implemented")
	case reflect.Map:
		panic("not yet implemented")
	case reflect.Ptr:
		val := go2GnoValue2(alloc, store, rv.Elem(), recursive)
		tv.V = PointerValue{TV: &val} // heap alloc
	case reflect.Struct:
		nf := rv.NumField()
		fs := alloc.NewStructFields(nf)
		for i := 0; i < nf; i++ {
			frv := rv.Field(i)
			if recursive {
				fs[i] = go2GnoValue2(alloc, store, frv, true)
			} else {
				fs[i] = go2GnoValue(alloc, frv)
			}
		}
		tv.V = alloc.NewStruct(fs)
	case reflect.UnsafePointer:
		panic("not yet implemented")
	default:
		panic("not yet implemented")
	}
	return
}

// ----------------------------------------
// Gno to Go conversion

// NOTE: Recursive types are not supported, as named types are not
// supported.  See https://github.com/golang/go/issues/20013 and
// https://github.com/golang/go/issues/39717.
func gno2GoType(t Type) reflect.Type {
	// special case if t == Float32Type or Float64Type
	if t == Float32Type {
		return reflect.TypeOf(float32(0.0))
	} else if t == Float64Type {
		return reflect.TypeOf(float64(0.0))
	}
	switch ct := baseOf(t).(type) {
	case PrimitiveType:
		switch ct {
		case BoolType, UntypedBoolType:
			return reflect.TypeOf(false)
		case StringType, UntypedStringType:
			return reflect.TypeOf("")
		case IntType:
			return reflect.TypeOf(int(0))
		case Int8Type:
			return reflect.TypeOf(int8(0))
		case Int16Type:
			return reflect.TypeOf(int16(0))
		case Int32Type, UntypedRuneType:
			return reflect.TypeOf(int32(0))
		case Int64Type:
			return reflect.TypeOf(int64(0))
		case UintType:
			return reflect.TypeOf(uint(0))
		case Uint8Type:
			return reflect.TypeOf(uint8(0))
		case Uint16Type:
			return reflect.TypeOf(uint16(0))
		case Uint32Type:
			return reflect.TypeOf(uint32(0))
		case Uint64Type:
			return reflect.TypeOf(uint64(0))
		case Float32Type:
			return reflect.TypeOf(float32(0))
		case Float64Type:
			return reflect.TypeOf(float64(0))
		case UntypedBigintType:
			panic("not yet implemented")
		case UntypedBigdecType:
			panic("not yet implemented")
		default:
			panic("should not happen")
		}
	case *PointerType:
		et := gno2GoType(ct.Elem())
		return reflect.PointerTo(et)
	case *ArrayType:
		ne := ct.Len
		et := gno2GoType(ct.Elem())
		return reflect.ArrayOf(ne, et)
	case *SliceType:
		et := gno2GoType(ct.Elem())
		return reflect.SliceOf(et)
	case *StructType:
		gfs := make([]reflect.StructField, len(ct.Fields))
		for i, field := range ct.Fields {
			gft := gno2GoType(field.Type)
			fn := string(field.Name)
			pkgPath := ""
			if !isUpper(fn) {
				pkgPath = ct.PkgPath
			}
			gfs[i] = reflect.StructField{
				Name:      fn,
				PkgPath:   pkgPath,
				Type:      gft,
				Tag:       reflect.StructTag(field.Tag),
				Anonymous: field.Name == "",
				// Offset: dontcare
				// Index: dontcare
			}
		}
		return reflect.StructOf(gfs)
	case *MapType:
		kt := gno2GoType(ct.Key)
		vt := gno2GoType(ct.Value)
		return reflect.MapOf(kt, vt)
	case *FuncType:
		panic("not yet supported")
	case *InterfaceType:
		if ct.IsEmptyInterface() {
			// XXX move out
			rt := reflect.TypeOf((*interface{})(nil)).Elem()
			return rt
		} else {
			// NOTE: can this be implemented in go1.15? i think not.
			panic("gno2go conversion of type not yet supported: " + ct.String())
		}
	case *TypeType:
		panic("should not happen")
	case *DeclaredType:
		// NOTE: Go1.15 has issues with generating types and values using
		// reflect to declare types with methods.  When Go has fixed these
		// issues, we can revisit.  For now, all Gno objects passed to Go
		// lose their names or "namedness", e.g. cannot satisfy anything
		// but empty interfaces, and have no methods.

		// We switch on baseOf(t).
		panic("should not happen")
	case *PackageType:
		panic("should not happen")
	default:
		panic(fmt.Sprintf("unexpected type %v with base %v", t, baseOf(t)))
	}
}

// rv must be addressable, or zero (invalid) (say if tv is referred to from a
// gno.PointerValue). In the latter case, an addressable one will be
// constructed and returned, otherwise returns rv.  if tv is undefined, rv must
// be valid.
//
// NOTE It doesn't make sense to add a 'store' argument here to support lazy
// loading (e.g. from native function bindings for SDKParams) because it
// doesn't really make sense in the general case, and there is a FillValue()
// function available for eager fetching of ref values.
func gno2GoValue(tv *TypedValue, rv reflect.Value) (ret reflect.Value) {
	if tv.IsUndefined() {
		if debug {
			if !rv.IsValid() {
				panic("unexpected undefined gno value")
			}
		}
		return rv
	}
	var rt reflect.Type
	bt := baseOf(tv.T)
	if !rv.IsValid() {
		rt = gno2GoType(bt)
		rv = reflect.New(rt).Elem()
		ret = rv
	} else if rv.Kind() == reflect.Interface {
		if debug {
			if !rv.IsZero() {
				panic("should not happen")
			}
		}
		rt = gno2GoType(bt)
		rv1 := rv
		rv2 := reflect.New(rt).Elem()
		rv = rv2       // swaparoo
		defer func() { // TODO: improve?
			rv1.Set(rv2)
			ret = rv
		}()
	} else {
		ret = rv
		rt = rv.Type()
	}
	switch ct := bt.(type) {
	case PrimitiveType:
		switch ct {
		case BoolType, UntypedBoolType:
			rv.SetBool(tv.GetBool())
		case StringType, UntypedStringType:
			rv.SetString(tv.GetString())
		case IntType:
			rv.SetInt(tv.GetInt())
		case Int8Type:
			rv.SetInt(int64(tv.GetInt8()))
		case Int16Type:
			rv.SetInt(int64(tv.GetInt16()))
		case Int32Type, UntypedRuneType:
			rv.SetInt(int64(tv.GetInt32()))
		case Int64Type:
			rv.SetInt(tv.GetInt64())
		case UintType:
			rv.SetUint(tv.GetUint())
		case Uint8Type:
			rv.SetUint(uint64(tv.GetUint8()))
		case Uint16Type:
			rv.SetUint(uint64(tv.GetUint16()))
		case Uint32Type:
			rv.SetUint(uint64(tv.GetUint32()))
		case Uint64Type:
			rv.SetUint(tv.GetUint64())
		case Float32Type:
			rv.SetFloat(math.Float64frombits(softfloat.F32to64(tv.GetFloat32())))
		case Float64Type:
			rv.SetFloat(math.Float64frombits(tv.GetFloat64()))
		default:
			panic(fmt.Sprintf(
				"unexpected type %s",
				tv.T.String()))
		}
	case *PointerType:
		// This doesn't take into account pointer relativity, or even
		// identical pointers -- every non-nil gno pointer type results in a
		// new addressable value in go.
		if tv.V == nil {
			// do nothing
		} else {
			rve := reflect.New(rv.Type().Elem()).Elem()
			rv2 := gno2GoValue(tv.V.(PointerValue).TV, rve)
			rv.Set(rv2.Addr())
		}
	case *ArrayType:
		if debug {
			if tv.V == nil {
				// all arguments and recursively fetched arrays
				// should have been initialized if not already so.
				panic("unexpected uninitialized array")
			}
		}
		// General case.
		av := tv.V.(*ArrayValue)
		if av.Data == nil {
			for i := 0; i < ct.Len; i++ {
				etv := &av.List[i]
				if etv.IsUndefined() {
					continue
				}
				gno2GoValue(etv, rv.Index(i))
			}
		} else {
			for i := 0; i < ct.Len; i++ {
				val := av.Data[i]
				erv := rv.Index(i)
				erv.SetUint(uint64(val))
			}
		}
	case *SliceType:
		st := rt
		// If uninitialized slice, return zero value.
		if tv.V == nil {
			return
		}
		// General case.
		sv := tv.V.(*SliceValue)
		svo := sv.Offset
		svl := sv.Length
		svc := sv.Maxcap
		svb := sv.GetBase(nil)
		if svb.Data == nil {
			rv.Set(reflect.MakeSlice(st, svl, svc))
			for i := 0; i < svl; i++ {
				etv := &(svb.List[svo+i])
				if etv.IsUndefined() {
					continue
				}
				gno2GoValue(etv, rv.Index(i))
			}
		} else {
			data := make([]byte, svl, svc)
			copy(data[:svc], svb.Data[svo:svo+svc])
			rv.Set(reflect.ValueOf(data))
		}
	case *StructType:
		// If uninitialized struct, return zero value.
		if tv.V == nil {
			return
		}
		// General case.
		sv := tv.V.(*StructValue)
		for i := range ct.Fields {
			ftv := &(sv.Fields[i])
			if ftv.IsUndefined() {
				continue
			}
			fv := rv.Field(i)
			if !fv.CanSet() {
				// Normally private fields can not bet set via reflect. Override this limitation.
				fv = reflect.NewAt(fv.Type(), unsafe.Pointer(fv.UnsafeAddr())).Elem()
			}
			gno2GoValue(ftv, fv)
		}
	case *MapType:
		// If uninitialized map, return zero value.
		if tv.V == nil {
			return
		}
		// General case.
		mv := tv.V.(*MapValue)
		mt := rt
		rv.Set(reflect.MakeMapWithSize(mt, mv.List.Size))
		head := mv.List.Head
		vrt := mt.Elem()
		for head != nil {
			ktv, vtv := &head.Key, &head.Value
			krv := gno2GoValue(ktv, reflect.Value{})
			if vtv.IsUndefined() {
				vrv := reflect.New(vrt).Elem()
				rv.SetMapIndex(krv, vrv)
			} else {
				vrv := gno2GoValue(vtv, reflect.Value{})
				rv.SetMapIndex(krv, vrv)
			}
			head = head.Next
		}
	case *DeclaredType:
		// See corresponding note on gno2GoType().
		panic("should not happen") // we switch on baseOf().
	case *FuncType:
		// TODO: if tv.V.(*NativeValue), just return.
		// TODO: otherwise, set rv to wrapper.
		panic("gno2Go not supported for gno functions yet")
	default:
		panic(fmt.Sprintf(
			"unexpected type %s",
			tv.T.String()))
	}
	return
}

// ----------------------------------------
// misc

func toChanDir(dir reflect.ChanDir) ChanDir {
	switch dir {
	case reflect.RecvDir:
		return RECV
	case reflect.SendDir:
		return SEND
	case reflect.BothDir:
		return BOTH
	default:
		panic("should not happn")
	}
}
